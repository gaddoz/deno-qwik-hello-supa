/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * PostgREST API
 * This is a dynamic API generated by PostgREST
 *
 * OpenAPI spec version: 11.2.0 (c820efb)
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:3000/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Divisions
 */
export interface Divisions {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {number}
     * @memberof Divisions
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Divisions
     */
    createdAt: string;
    /**
     * Note: This is a Foreign Key to `sports.id`.<fk table='sports' column='id'/>
     * @type {number}
     * @memberof Divisions
     */
    sportId?: number;
    /**
     * 
     * @type {string}
     * @memberof Divisions
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface EventFormatDivisions
 */
export interface EventFormatDivisions {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {number}
     * @memberof EventFormatDivisions
     */
    id: number;
    /**
     * Note: This is a Foreign Key to `sports.id`.<fk table='sports' column='id'/>
     * @type {number}
     * @memberof EventFormatDivisions
     */
    sportId?: number;
    /**
     * Note: This is a Foreign Key to `formats.id`.<fk table='formats' column='id'/>
     * @type {number}
     * @memberof EventFormatDivisions
     */
    formatId?: number;
    /**
     * Note: This is a Foreign Key to `divisions.id`.<fk table='divisions' column='id'/>
     * @type {number}
     * @memberof EventFormatDivisions
     */
    divisionId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EventFormatDivisions
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EventFormatDivisions
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface Events
 */
export interface Events {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {number}
     * @memberof Events
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    ownerId: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Events
     */
    publicListing: boolean;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    registrationOpen?: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    registrationClose?: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    eventStart?: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    eventEnd?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Events
     */
    registrationEnabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    eventLocation?: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    slug?: string;
    /**
     * 
     * @type {number}
     * @memberof Events
     */
    _public: number;
}
/**
 * 
 * @export
 * @interface EventsRegistrations
 */
export interface EventsRegistrations {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof EventsRegistrations
     */
    id: string;
    /**
     * Note: This is a Foreign Key to `events.id`.<fk table='events' column='id'/>
     * @type {number}
     * @memberof EventsRegistrations
     */
    eventId?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsRegistrations
     */
    playerFirstname?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsRegistrations
     */
    playerLastname?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsRegistrations
     */
    playerEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsRegistrations
     */
    playerCountry?: string;
    /**
     * 
     * @type {number}
     * @memberof EventsRegistrations
     */
    playerDinner?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsRegistrations
     */
    playerDivision?: string;
    /**
     * 
     * @type {any}
     * @memberof EventsRegistrations
     */
    playerCategories?: any;
    /**
     * 
     * @type {string}
     * @memberof EventsRegistrations
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof EventsRegistrations
     */
    modifiedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsRegistrations
     */
    playerPhone?: string;
    /**
     * 
     * @type {any}
     * @memberof EventsRegistrations
     */
    playerMusic?: any;
    /**
     * 
     * @type {number}
     * @memberof EventsRegistrations
     */
    playerDogAge?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsRegistrations
     */
    playerDogName?: string;
}
/**
 * 
 * @export
 * @interface Formats
 */
export interface Formats {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {number}
     * @memberof Formats
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Formats
     */
    name?: string;
    /**
     * Note: This is a Foreign Key to `sports.id`.<fk table='sports' column='id'/>
     * @type {number}
     * @memberof Formats
     */
    sportId?: number;
    /**
     * 
     * @type {string}
     * @memberof Formats
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface Profiles
 */
export interface Profiles {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {string}
     * @memberof Profiles
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    updatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    fullName?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    avatarUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Profiles
     */
    website?: string;
}
/**
 * 
 * @export
 * @interface RpcDeleteAvatarBody
 */
export interface RpcDeleteAvatarBody {
    /**
     * 
     * @type {string}
     * @memberof RpcDeleteAvatarBody
     */
    avatarUrl: string;
}
/**
 * 
 * @export
 * @interface RpcDeleteAvatarBody1
 */
export interface RpcDeleteAvatarBody1 {
    /**
     * 
     * @type {string}
     * @memberof RpcDeleteAvatarBody1
     */
    avatarUrl: string;
}
/**
 * 
 * @export
 * @interface RpcDeleteAvatarBody2
 */
export interface RpcDeleteAvatarBody2 {
    /**
     * 
     * @type {string}
     * @memberof RpcDeleteAvatarBody2
     */
    avatarUrl: string;
}
/**
 * 
 * @export
 * @interface RpcDeleteAvatarBody3
 */
export interface RpcDeleteAvatarBody3 {
    /**
     * 
     * @type {string}
     * @memberof RpcDeleteAvatarBody3
     */
    avatarUrl: string;
}
/**
 * 
 * @export
 * @interface RpcDeleteStorageObjectBody
 */
export interface RpcDeleteStorageObjectBody {
    /**
     * 
     * @type {string}
     * @memberof RpcDeleteStorageObjectBody
     */
    bucket: string;
    /**
     * 
     * @type {string}
     * @memberof RpcDeleteStorageObjectBody
     */
    object: string;
}
/**
 * 
 * @export
 * @interface RpcDeleteStorageObjectBody1
 */
export interface RpcDeleteStorageObjectBody1 {
    /**
     * 
     * @type {string}
     * @memberof RpcDeleteStorageObjectBody1
     */
    bucket: string;
    /**
     * 
     * @type {string}
     * @memberof RpcDeleteStorageObjectBody1
     */
    object: string;
}
/**
 * 
 * @export
 * @interface RpcDeleteStorageObjectBody2
 */
export interface RpcDeleteStorageObjectBody2 {
    /**
     * 
     * @type {string}
     * @memberof RpcDeleteStorageObjectBody2
     */
    bucket: string;
    /**
     * 
     * @type {string}
     * @memberof RpcDeleteStorageObjectBody2
     */
    object: string;
}
/**
 * 
 * @export
 * @interface RpcDeleteStorageObjectBody3
 */
export interface RpcDeleteStorageObjectBody3 {
    /**
     * 
     * @type {string}
     * @memberof RpcDeleteStorageObjectBody3
     */
    bucket: string;
    /**
     * 
     * @type {string}
     * @memberof RpcDeleteStorageObjectBody3
     */
    object: string;
}
/**
 * 
 * @export
 * @interface Sports
 */
export interface Sports {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {number}
     * @memberof Sports
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Sports
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Sports
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface Todos
 */
export interface Todos {
    /**
     * Note: This is a Primary Key.<pk/>
     * @type {number}
     * @memberof Todos
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Todos
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Todos
     */
    task?: string;
    /**
     * 
     * @type {string}
     * @memberof Todos
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Todos
     */
    userId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Todos
     */
    completed?: boolean;
}
/**
 * DivisionsApi - fetch parameter creator
 * @export
 */
export const DivisionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [sportId] 
         * @param {string} [name] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsDelete(id?: string, createdAt?: string, sportId?: string, name?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/divisions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (sportId !== undefined) {
                localVarQueryParameter['sport_id'] = sportId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [sportId] 
         * @param {string} [name] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsGet(id?: string, createdAt?: string, sportId?: string, name?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/divisions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (sportId !== undefined) {
                localVarQueryParameter['sport_id'] = sportId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Divisions} [body] divisions
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [sportId] 
         * @param {string} [name] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsPatch(body?: Divisions, id?: string, createdAt?: string, sportId?: string, name?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/divisions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (sportId !== undefined) {
                localVarQueryParameter['sport_id'] = sportId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Divisions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Divisions} [body] divisions
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsPost(body?: Divisions, select?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/divisions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Divisions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DivisionsApi - functional programming interface
 * @export
 */
export const DivisionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [sportId] 
         * @param {string} [name] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsDelete(id?: string, createdAt?: string, sportId?: string, name?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DivisionsApiFetchParamCreator(configuration).divisionsDelete(id, createdAt, sportId, name, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [sportId] 
         * @param {string} [name] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsGet(id?: string, createdAt?: string, sportId?: string, name?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Divisions>> {
            const localVarFetchArgs = DivisionsApiFetchParamCreator(configuration).divisionsGet(id, createdAt, sportId, name, select, order, range, rangeUnit, offset, limit, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Divisions} [body] divisions
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [sportId] 
         * @param {string} [name] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsPatch(body?: Divisions, id?: string, createdAt?: string, sportId?: string, name?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DivisionsApiFetchParamCreator(configuration).divisionsPatch(body, id, createdAt, sportId, name, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Divisions} [body] divisions
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsPost(body?: Divisions, select?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DivisionsApiFetchParamCreator(configuration).divisionsPost(body, select, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DivisionsApi - factory interface
 * @export
 */
export const DivisionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [sportId] 
         * @param {string} [name] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsDelete(id?: string, createdAt?: string, sportId?: string, name?: string, prefer?: string, options?: any) {
            return DivisionsApiFp(configuration).divisionsDelete(id, createdAt, sportId, name, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [sportId] 
         * @param {string} [name] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsGet(id?: string, createdAt?: string, sportId?: string, name?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
            return DivisionsApiFp(configuration).divisionsGet(id, createdAt, sportId, name, select, order, range, rangeUnit, offset, limit, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Divisions} [body] divisions
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [sportId] 
         * @param {string} [name] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsPatch(body?: Divisions, id?: string, createdAt?: string, sportId?: string, name?: string, prefer?: string, options?: any) {
            return DivisionsApiFp(configuration).divisionsPatch(body, id, createdAt, sportId, name, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Divisions} [body] divisions
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        divisionsPost(body?: Divisions, select?: string, prefer?: string, options?: any) {
            return DivisionsApiFp(configuration).divisionsPost(body, select, prefer, options)(fetch, basePath);
        },
    };
};

/**
 * DivisionsApi - object-oriented interface
 * @export
 * @class DivisionsApi
 * @extends {BaseAPI}
 */
export class DivisionsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [sportId] 
     * @param {string} [name] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public divisionsDelete(id?: string, createdAt?: string, sportId?: string, name?: string, prefer?: string, options?: any) {
        return DivisionsApiFp(this.configuration).divisionsDelete(id, createdAt, sportId, name, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [sportId] 
     * @param {string} [name] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public divisionsGet(id?: string, createdAt?: string, sportId?: string, name?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
        return DivisionsApiFp(this.configuration).divisionsGet(id, createdAt, sportId, name, select, order, range, rangeUnit, offset, limit, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Divisions} [body] divisions
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [sportId] 
     * @param {string} [name] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public divisionsPatch(body?: Divisions, id?: string, createdAt?: string, sportId?: string, name?: string, prefer?: string, options?: any) {
        return DivisionsApiFp(this.configuration).divisionsPatch(body, id, createdAt, sportId, name, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Divisions} [body] divisions
     * @param {string} [select] Filtering Columns
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public divisionsPost(body?: Divisions, select?: string, prefer?: string, options?: any) {
        return DivisionsApiFp(this.configuration).divisionsPost(body, select, prefer, options)(this.fetch, this.basePath);
    }

}
/**
 * EventFormatDivisionsApi - fetch parameter creator
 * @export
 */
export const EventFormatDivisionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [sportId] 
         * @param {string} [formatId] 
         * @param {string} [divisionId] 
         * @param {string} [enabled] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventFormatDivisionsDelete(id?: string, sportId?: string, formatId?: string, divisionId?: string, enabled?: string, createdAt?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/event_format_divisions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (sportId !== undefined) {
                localVarQueryParameter['sport_id'] = sportId;
            }

            if (formatId !== undefined) {
                localVarQueryParameter['format_id'] = formatId;
            }

            if (divisionId !== undefined) {
                localVarQueryParameter['division_id'] = divisionId;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [sportId] 
         * @param {string} [formatId] 
         * @param {string} [divisionId] 
         * @param {string} [enabled] 
         * @param {string} [createdAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventFormatDivisionsGet(id?: string, sportId?: string, formatId?: string, divisionId?: string, enabled?: string, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/event_format_divisions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (sportId !== undefined) {
                localVarQueryParameter['sport_id'] = sportId;
            }

            if (formatId !== undefined) {
                localVarQueryParameter['format_id'] = formatId;
            }

            if (divisionId !== undefined) {
                localVarQueryParameter['division_id'] = divisionId;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EventFormatDivisions} [body] event_format_divisions
         * @param {string} [id] 
         * @param {string} [sportId] 
         * @param {string} [formatId] 
         * @param {string} [divisionId] 
         * @param {string} [enabled] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventFormatDivisionsPatch(body?: EventFormatDivisions, id?: string, sportId?: string, formatId?: string, divisionId?: string, enabled?: string, createdAt?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/event_format_divisions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (sportId !== undefined) {
                localVarQueryParameter['sport_id'] = sportId;
            }

            if (formatId !== undefined) {
                localVarQueryParameter['format_id'] = formatId;
            }

            if (divisionId !== undefined) {
                localVarQueryParameter['division_id'] = divisionId;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventFormatDivisions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EventFormatDivisions} [body] event_format_divisions
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventFormatDivisionsPost(body?: EventFormatDivisions, select?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/event_format_divisions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventFormatDivisions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventFormatDivisionsApi - functional programming interface
 * @export
 */
export const EventFormatDivisionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [sportId] 
         * @param {string} [formatId] 
         * @param {string} [divisionId] 
         * @param {string} [enabled] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventFormatDivisionsDelete(id?: string, sportId?: string, formatId?: string, divisionId?: string, enabled?: string, createdAt?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EventFormatDivisionsApiFetchParamCreator(configuration).eventFormatDivisionsDelete(id, sportId, formatId, divisionId, enabled, createdAt, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [sportId] 
         * @param {string} [formatId] 
         * @param {string} [divisionId] 
         * @param {string} [enabled] 
         * @param {string} [createdAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventFormatDivisionsGet(id?: string, sportId?: string, formatId?: string, divisionId?: string, enabled?: string, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventFormatDivisions>> {
            const localVarFetchArgs = EventFormatDivisionsApiFetchParamCreator(configuration).eventFormatDivisionsGet(id, sportId, formatId, divisionId, enabled, createdAt, select, order, range, rangeUnit, offset, limit, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EventFormatDivisions} [body] event_format_divisions
         * @param {string} [id] 
         * @param {string} [sportId] 
         * @param {string} [formatId] 
         * @param {string} [divisionId] 
         * @param {string} [enabled] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventFormatDivisionsPatch(body?: EventFormatDivisions, id?: string, sportId?: string, formatId?: string, divisionId?: string, enabled?: string, createdAt?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EventFormatDivisionsApiFetchParamCreator(configuration).eventFormatDivisionsPatch(body, id, sportId, formatId, divisionId, enabled, createdAt, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EventFormatDivisions} [body] event_format_divisions
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventFormatDivisionsPost(body?: EventFormatDivisions, select?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EventFormatDivisionsApiFetchParamCreator(configuration).eventFormatDivisionsPost(body, select, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventFormatDivisionsApi - factory interface
 * @export
 */
export const EventFormatDivisionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [sportId] 
         * @param {string} [formatId] 
         * @param {string} [divisionId] 
         * @param {string} [enabled] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventFormatDivisionsDelete(id?: string, sportId?: string, formatId?: string, divisionId?: string, enabled?: string, createdAt?: string, prefer?: string, options?: any) {
            return EventFormatDivisionsApiFp(configuration).eventFormatDivisionsDelete(id, sportId, formatId, divisionId, enabled, createdAt, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [sportId] 
         * @param {string} [formatId] 
         * @param {string} [divisionId] 
         * @param {string} [enabled] 
         * @param {string} [createdAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventFormatDivisionsGet(id?: string, sportId?: string, formatId?: string, divisionId?: string, enabled?: string, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
            return EventFormatDivisionsApiFp(configuration).eventFormatDivisionsGet(id, sportId, formatId, divisionId, enabled, createdAt, select, order, range, rangeUnit, offset, limit, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EventFormatDivisions} [body] event_format_divisions
         * @param {string} [id] 
         * @param {string} [sportId] 
         * @param {string} [formatId] 
         * @param {string} [divisionId] 
         * @param {string} [enabled] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventFormatDivisionsPatch(body?: EventFormatDivisions, id?: string, sportId?: string, formatId?: string, divisionId?: string, enabled?: string, createdAt?: string, prefer?: string, options?: any) {
            return EventFormatDivisionsApiFp(configuration).eventFormatDivisionsPatch(body, id, sportId, formatId, divisionId, enabled, createdAt, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EventFormatDivisions} [body] event_format_divisions
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventFormatDivisionsPost(body?: EventFormatDivisions, select?: string, prefer?: string, options?: any) {
            return EventFormatDivisionsApiFp(configuration).eventFormatDivisionsPost(body, select, prefer, options)(fetch, basePath);
        },
    };
};

/**
 * EventFormatDivisionsApi - object-oriented interface
 * @export
 * @class EventFormatDivisionsApi
 * @extends {BaseAPI}
 */
export class EventFormatDivisionsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [sportId] 
     * @param {string} [formatId] 
     * @param {string} [divisionId] 
     * @param {string} [enabled] 
     * @param {string} [createdAt] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventFormatDivisionsApi
     */
    public eventFormatDivisionsDelete(id?: string, sportId?: string, formatId?: string, divisionId?: string, enabled?: string, createdAt?: string, prefer?: string, options?: any) {
        return EventFormatDivisionsApiFp(this.configuration).eventFormatDivisionsDelete(id, sportId, formatId, divisionId, enabled, createdAt, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [sportId] 
     * @param {string} [formatId] 
     * @param {string} [divisionId] 
     * @param {string} [enabled] 
     * @param {string} [createdAt] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventFormatDivisionsApi
     */
    public eventFormatDivisionsGet(id?: string, sportId?: string, formatId?: string, divisionId?: string, enabled?: string, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
        return EventFormatDivisionsApiFp(this.configuration).eventFormatDivisionsGet(id, sportId, formatId, divisionId, enabled, createdAt, select, order, range, rangeUnit, offset, limit, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {EventFormatDivisions} [body] event_format_divisions
     * @param {string} [id] 
     * @param {string} [sportId] 
     * @param {string} [formatId] 
     * @param {string} [divisionId] 
     * @param {string} [enabled] 
     * @param {string} [createdAt] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventFormatDivisionsApi
     */
    public eventFormatDivisionsPatch(body?: EventFormatDivisions, id?: string, sportId?: string, formatId?: string, divisionId?: string, enabled?: string, createdAt?: string, prefer?: string, options?: any) {
        return EventFormatDivisionsApiFp(this.configuration).eventFormatDivisionsPatch(body, id, sportId, formatId, divisionId, enabled, createdAt, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {EventFormatDivisions} [body] event_format_divisions
     * @param {string} [select] Filtering Columns
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventFormatDivisionsApi
     */
    public eventFormatDivisionsPost(body?: EventFormatDivisions, select?: string, prefer?: string, options?: any) {
        return EventFormatDivisionsApiFp(this.configuration).eventFormatDivisionsPost(body, select, prefer, options)(this.fetch, this.basePath);
    }

}
/**
 * EventsApi - fetch parameter creator
 * @export
 */
export const EventsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ownerId] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [publicListing] 
         * @param {string} [registrationOpen] 
         * @param {string} [registrationClose] 
         * @param {string} [eventStart] 
         * @param {string} [eventEnd] 
         * @param {string} [registrationEnabled] 
         * @param {string} [eventLocation] 
         * @param {string} [slug] 
         * @param {string} [_public] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsDelete(id?: string, createdAt?: string, ownerId?: string, title?: string, description?: string, publicListing?: string, registrationOpen?: string, registrationClose?: string, eventStart?: string, eventEnd?: string, registrationEnabled?: string, eventLocation?: string, slug?: string, _public?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['owner_id'] = ownerId;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (publicListing !== undefined) {
                localVarQueryParameter['public_listing'] = publicListing;
            }

            if (registrationOpen !== undefined) {
                localVarQueryParameter['registration_open'] = registrationOpen;
            }

            if (registrationClose !== undefined) {
                localVarQueryParameter['registration_close'] = registrationClose;
            }

            if (eventStart !== undefined) {
                localVarQueryParameter['event_start'] = eventStart;
            }

            if (eventEnd !== undefined) {
                localVarQueryParameter['event_end'] = eventEnd;
            }

            if (registrationEnabled !== undefined) {
                localVarQueryParameter['registration_enabled'] = registrationEnabled;
            }

            if (eventLocation !== undefined) {
                localVarQueryParameter['event_location'] = eventLocation;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (_public !== undefined) {
                localVarQueryParameter['public'] = _public;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ownerId] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [publicListing] 
         * @param {string} [registrationOpen] 
         * @param {string} [registrationClose] 
         * @param {string} [eventStart] 
         * @param {string} [eventEnd] 
         * @param {string} [registrationEnabled] 
         * @param {string} [eventLocation] 
         * @param {string} [slug] 
         * @param {string} [_public] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGet(id?: string, createdAt?: string, ownerId?: string, title?: string, description?: string, publicListing?: string, registrationOpen?: string, registrationClose?: string, eventStart?: string, eventEnd?: string, registrationEnabled?: string, eventLocation?: string, slug?: string, _public?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['owner_id'] = ownerId;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (publicListing !== undefined) {
                localVarQueryParameter['public_listing'] = publicListing;
            }

            if (registrationOpen !== undefined) {
                localVarQueryParameter['registration_open'] = registrationOpen;
            }

            if (registrationClose !== undefined) {
                localVarQueryParameter['registration_close'] = registrationClose;
            }

            if (eventStart !== undefined) {
                localVarQueryParameter['event_start'] = eventStart;
            }

            if (eventEnd !== undefined) {
                localVarQueryParameter['event_end'] = eventEnd;
            }

            if (registrationEnabled !== undefined) {
                localVarQueryParameter['registration_enabled'] = registrationEnabled;
            }

            if (eventLocation !== undefined) {
                localVarQueryParameter['event_location'] = eventLocation;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (_public !== undefined) {
                localVarQueryParameter['public'] = _public;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Events} [body] events
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ownerId] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [publicListing] 
         * @param {string} [registrationOpen] 
         * @param {string} [registrationClose] 
         * @param {string} [eventStart] 
         * @param {string} [eventEnd] 
         * @param {string} [registrationEnabled] 
         * @param {string} [eventLocation] 
         * @param {string} [slug] 
         * @param {string} [_public] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPatch(body?: Events, id?: string, createdAt?: string, ownerId?: string, title?: string, description?: string, publicListing?: string, registrationOpen?: string, registrationClose?: string, eventStart?: string, eventEnd?: string, registrationEnabled?: string, eventLocation?: string, slug?: string, _public?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['owner_id'] = ownerId;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (publicListing !== undefined) {
                localVarQueryParameter['public_listing'] = publicListing;
            }

            if (registrationOpen !== undefined) {
                localVarQueryParameter['registration_open'] = registrationOpen;
            }

            if (registrationClose !== undefined) {
                localVarQueryParameter['registration_close'] = registrationClose;
            }

            if (eventStart !== undefined) {
                localVarQueryParameter['event_start'] = eventStart;
            }

            if (eventEnd !== undefined) {
                localVarQueryParameter['event_end'] = eventEnd;
            }

            if (registrationEnabled !== undefined) {
                localVarQueryParameter['registration_enabled'] = registrationEnabled;
            }

            if (eventLocation !== undefined) {
                localVarQueryParameter['event_location'] = eventLocation;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (_public !== undefined) {
                localVarQueryParameter['public'] = _public;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Events" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Events} [body] events
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPost(body?: Events, select?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Events" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ownerId] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [publicListing] 
         * @param {string} [registrationOpen] 
         * @param {string} [registrationClose] 
         * @param {string} [eventStart] 
         * @param {string} [eventEnd] 
         * @param {string} [registrationEnabled] 
         * @param {string} [eventLocation] 
         * @param {string} [slug] 
         * @param {string} [_public] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsDelete(id?: string, createdAt?: string, ownerId?: string, title?: string, description?: string, publicListing?: string, registrationOpen?: string, registrationClose?: string, eventStart?: string, eventEnd?: string, registrationEnabled?: string, eventLocation?: string, slug?: string, _public?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsDelete(id, createdAt, ownerId, title, description, publicListing, registrationOpen, registrationClose, eventStart, eventEnd, registrationEnabled, eventLocation, slug, _public, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ownerId] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [publicListing] 
         * @param {string} [registrationOpen] 
         * @param {string} [registrationClose] 
         * @param {string} [eventStart] 
         * @param {string} [eventEnd] 
         * @param {string} [registrationEnabled] 
         * @param {string} [eventLocation] 
         * @param {string} [slug] 
         * @param {string} [_public] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGet(id?: string, createdAt?: string, ownerId?: string, title?: string, description?: string, publicListing?: string, registrationOpen?: string, registrationClose?: string, eventStart?: string, eventEnd?: string, registrationEnabled?: string, eventLocation?: string, slug?: string, _public?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Events>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsGet(id, createdAt, ownerId, title, description, publicListing, registrationOpen, registrationClose, eventStart, eventEnd, registrationEnabled, eventLocation, slug, _public, select, order, range, rangeUnit, offset, limit, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Events} [body] events
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ownerId] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [publicListing] 
         * @param {string} [registrationOpen] 
         * @param {string} [registrationClose] 
         * @param {string} [eventStart] 
         * @param {string} [eventEnd] 
         * @param {string} [registrationEnabled] 
         * @param {string} [eventLocation] 
         * @param {string} [slug] 
         * @param {string} [_public] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPatch(body?: Events, id?: string, createdAt?: string, ownerId?: string, title?: string, description?: string, publicListing?: string, registrationOpen?: string, registrationClose?: string, eventStart?: string, eventEnd?: string, registrationEnabled?: string, eventLocation?: string, slug?: string, _public?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsPatch(body, id, createdAt, ownerId, title, description, publicListing, registrationOpen, registrationClose, eventStart, eventEnd, registrationEnabled, eventLocation, slug, _public, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Events} [body] events
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPost(body?: Events, select?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsPost(body, select, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ownerId] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [publicListing] 
         * @param {string} [registrationOpen] 
         * @param {string} [registrationClose] 
         * @param {string} [eventStart] 
         * @param {string} [eventEnd] 
         * @param {string} [registrationEnabled] 
         * @param {string} [eventLocation] 
         * @param {string} [slug] 
         * @param {string} [_public] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsDelete(id?: string, createdAt?: string, ownerId?: string, title?: string, description?: string, publicListing?: string, registrationOpen?: string, registrationClose?: string, eventStart?: string, eventEnd?: string, registrationEnabled?: string, eventLocation?: string, slug?: string, _public?: string, prefer?: string, options?: any) {
            return EventsApiFp(configuration).eventsDelete(id, createdAt, ownerId, title, description, publicListing, registrationOpen, registrationClose, eventStart, eventEnd, registrationEnabled, eventLocation, slug, _public, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ownerId] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [publicListing] 
         * @param {string} [registrationOpen] 
         * @param {string} [registrationClose] 
         * @param {string} [eventStart] 
         * @param {string} [eventEnd] 
         * @param {string} [registrationEnabled] 
         * @param {string} [eventLocation] 
         * @param {string} [slug] 
         * @param {string} [_public] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGet(id?: string, createdAt?: string, ownerId?: string, title?: string, description?: string, publicListing?: string, registrationOpen?: string, registrationClose?: string, eventStart?: string, eventEnd?: string, registrationEnabled?: string, eventLocation?: string, slug?: string, _public?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
            return EventsApiFp(configuration).eventsGet(id, createdAt, ownerId, title, description, publicListing, registrationOpen, registrationClose, eventStart, eventEnd, registrationEnabled, eventLocation, slug, _public, select, order, range, rangeUnit, offset, limit, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Events} [body] events
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [ownerId] 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [publicListing] 
         * @param {string} [registrationOpen] 
         * @param {string} [registrationClose] 
         * @param {string} [eventStart] 
         * @param {string} [eventEnd] 
         * @param {string} [registrationEnabled] 
         * @param {string} [eventLocation] 
         * @param {string} [slug] 
         * @param {string} [_public] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPatch(body?: Events, id?: string, createdAt?: string, ownerId?: string, title?: string, description?: string, publicListing?: string, registrationOpen?: string, registrationClose?: string, eventStart?: string, eventEnd?: string, registrationEnabled?: string, eventLocation?: string, slug?: string, _public?: string, prefer?: string, options?: any) {
            return EventsApiFp(configuration).eventsPatch(body, id, createdAt, ownerId, title, description, publicListing, registrationOpen, registrationClose, eventStart, eventEnd, registrationEnabled, eventLocation, slug, _public, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Events} [body] events
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPost(body?: Events, select?: string, prefer?: string, options?: any) {
            return EventsApiFp(configuration).eventsPost(body, select, prefer, options)(fetch, basePath);
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [ownerId] 
     * @param {string} [title] 
     * @param {string} [description] 
     * @param {string} [publicListing] 
     * @param {string} [registrationOpen] 
     * @param {string} [registrationClose] 
     * @param {string} [eventStart] 
     * @param {string} [eventEnd] 
     * @param {string} [registrationEnabled] 
     * @param {string} [eventLocation] 
     * @param {string} [slug] 
     * @param {string} [_public] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsDelete(id?: string, createdAt?: string, ownerId?: string, title?: string, description?: string, publicListing?: string, registrationOpen?: string, registrationClose?: string, eventStart?: string, eventEnd?: string, registrationEnabled?: string, eventLocation?: string, slug?: string, _public?: string, prefer?: string, options?: any) {
        return EventsApiFp(this.configuration).eventsDelete(id, createdAt, ownerId, title, description, publicListing, registrationOpen, registrationClose, eventStart, eventEnd, registrationEnabled, eventLocation, slug, _public, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [ownerId] 
     * @param {string} [title] 
     * @param {string} [description] 
     * @param {string} [publicListing] 
     * @param {string} [registrationOpen] 
     * @param {string} [registrationClose] 
     * @param {string} [eventStart] 
     * @param {string} [eventEnd] 
     * @param {string} [registrationEnabled] 
     * @param {string} [eventLocation] 
     * @param {string} [slug] 
     * @param {string} [_public] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsGet(id?: string, createdAt?: string, ownerId?: string, title?: string, description?: string, publicListing?: string, registrationOpen?: string, registrationClose?: string, eventStart?: string, eventEnd?: string, registrationEnabled?: string, eventLocation?: string, slug?: string, _public?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
        return EventsApiFp(this.configuration).eventsGet(id, createdAt, ownerId, title, description, publicListing, registrationOpen, registrationClose, eventStart, eventEnd, registrationEnabled, eventLocation, slug, _public, select, order, range, rangeUnit, offset, limit, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Events} [body] events
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [ownerId] 
     * @param {string} [title] 
     * @param {string} [description] 
     * @param {string} [publicListing] 
     * @param {string} [registrationOpen] 
     * @param {string} [registrationClose] 
     * @param {string} [eventStart] 
     * @param {string} [eventEnd] 
     * @param {string} [registrationEnabled] 
     * @param {string} [eventLocation] 
     * @param {string} [slug] 
     * @param {string} [_public] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsPatch(body?: Events, id?: string, createdAt?: string, ownerId?: string, title?: string, description?: string, publicListing?: string, registrationOpen?: string, registrationClose?: string, eventStart?: string, eventEnd?: string, registrationEnabled?: string, eventLocation?: string, slug?: string, _public?: string, prefer?: string, options?: any) {
        return EventsApiFp(this.configuration).eventsPatch(body, id, createdAt, ownerId, title, description, publicListing, registrationOpen, registrationClose, eventStart, eventEnd, registrationEnabled, eventLocation, slug, _public, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Events} [body] events
     * @param {string} [select] Filtering Columns
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsPost(body?: Events, select?: string, prefer?: string, options?: any) {
        return EventsApiFp(this.configuration).eventsPost(body, select, prefer, options)(this.fetch, this.basePath);
    }

}
/**
 * EventsRegistrationsApi - fetch parameter creator
 * @export
 */
export const EventsRegistrationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [eventId] 
         * @param {string} [playerFirstname] 
         * @param {string} [playerLastname] 
         * @param {string} [playerEmail] 
         * @param {string} [playerCountry] 
         * @param {string} [playerDinner] 
         * @param {string} [playerDivision] 
         * @param {string} [playerCategories] 
         * @param {string} [createdAt] 
         * @param {string} [modifiedAt] 
         * @param {string} [playerPhone] 
         * @param {string} [playerMusic] 
         * @param {string} [playerDogAge] 
         * @param {string} [playerDogName] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRegistrationsDelete(id?: string, eventId?: string, playerFirstname?: string, playerLastname?: string, playerEmail?: string, playerCountry?: string, playerDinner?: string, playerDivision?: string, playerCategories?: string, createdAt?: string, modifiedAt?: string, playerPhone?: string, playerMusic?: string, playerDogAge?: string, playerDogName?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/events_registrations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['event_id'] = eventId;
            }

            if (playerFirstname !== undefined) {
                localVarQueryParameter['player_firstname'] = playerFirstname;
            }

            if (playerLastname !== undefined) {
                localVarQueryParameter['player_lastname'] = playerLastname;
            }

            if (playerEmail !== undefined) {
                localVarQueryParameter['player_email'] = playerEmail;
            }

            if (playerCountry !== undefined) {
                localVarQueryParameter['player_country'] = playerCountry;
            }

            if (playerDinner !== undefined) {
                localVarQueryParameter['player_dinner'] = playerDinner;
            }

            if (playerDivision !== undefined) {
                localVarQueryParameter['player_division'] = playerDivision;
            }

            if (playerCategories !== undefined) {
                localVarQueryParameter['player_categories'] = playerCategories;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (modifiedAt !== undefined) {
                localVarQueryParameter['modified_at'] = modifiedAt;
            }

            if (playerPhone !== undefined) {
                localVarQueryParameter['player_phone'] = playerPhone;
            }

            if (playerMusic !== undefined) {
                localVarQueryParameter['player_music'] = playerMusic;
            }

            if (playerDogAge !== undefined) {
                localVarQueryParameter['player_dog_age'] = playerDogAge;
            }

            if (playerDogName !== undefined) {
                localVarQueryParameter['player_dog_name'] = playerDogName;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [eventId] 
         * @param {string} [playerFirstname] 
         * @param {string} [playerLastname] 
         * @param {string} [playerEmail] 
         * @param {string} [playerCountry] 
         * @param {string} [playerDinner] 
         * @param {string} [playerDivision] 
         * @param {string} [playerCategories] 
         * @param {string} [createdAt] 
         * @param {string} [modifiedAt] 
         * @param {string} [playerPhone] 
         * @param {string} [playerMusic] 
         * @param {string} [playerDogAge] 
         * @param {string} [playerDogName] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRegistrationsGet(id?: string, eventId?: string, playerFirstname?: string, playerLastname?: string, playerEmail?: string, playerCountry?: string, playerDinner?: string, playerDivision?: string, playerCategories?: string, createdAt?: string, modifiedAt?: string, playerPhone?: string, playerMusic?: string, playerDogAge?: string, playerDogName?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/events_registrations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['event_id'] = eventId;
            }

            if (playerFirstname !== undefined) {
                localVarQueryParameter['player_firstname'] = playerFirstname;
            }

            if (playerLastname !== undefined) {
                localVarQueryParameter['player_lastname'] = playerLastname;
            }

            if (playerEmail !== undefined) {
                localVarQueryParameter['player_email'] = playerEmail;
            }

            if (playerCountry !== undefined) {
                localVarQueryParameter['player_country'] = playerCountry;
            }

            if (playerDinner !== undefined) {
                localVarQueryParameter['player_dinner'] = playerDinner;
            }

            if (playerDivision !== undefined) {
                localVarQueryParameter['player_division'] = playerDivision;
            }

            if (playerCategories !== undefined) {
                localVarQueryParameter['player_categories'] = playerCategories;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (modifiedAt !== undefined) {
                localVarQueryParameter['modified_at'] = modifiedAt;
            }

            if (playerPhone !== undefined) {
                localVarQueryParameter['player_phone'] = playerPhone;
            }

            if (playerMusic !== undefined) {
                localVarQueryParameter['player_music'] = playerMusic;
            }

            if (playerDogAge !== undefined) {
                localVarQueryParameter['player_dog_age'] = playerDogAge;
            }

            if (playerDogName !== undefined) {
                localVarQueryParameter['player_dog_name'] = playerDogName;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EventsRegistrations} [body] events_registrations
         * @param {string} [id] 
         * @param {string} [eventId] 
         * @param {string} [playerFirstname] 
         * @param {string} [playerLastname] 
         * @param {string} [playerEmail] 
         * @param {string} [playerCountry] 
         * @param {string} [playerDinner] 
         * @param {string} [playerDivision] 
         * @param {string} [playerCategories] 
         * @param {string} [createdAt] 
         * @param {string} [modifiedAt] 
         * @param {string} [playerPhone] 
         * @param {string} [playerMusic] 
         * @param {string} [playerDogAge] 
         * @param {string} [playerDogName] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRegistrationsPatch(body?: EventsRegistrations, id?: string, eventId?: string, playerFirstname?: string, playerLastname?: string, playerEmail?: string, playerCountry?: string, playerDinner?: string, playerDivision?: string, playerCategories?: string, createdAt?: string, modifiedAt?: string, playerPhone?: string, playerMusic?: string, playerDogAge?: string, playerDogName?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/events_registrations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['event_id'] = eventId;
            }

            if (playerFirstname !== undefined) {
                localVarQueryParameter['player_firstname'] = playerFirstname;
            }

            if (playerLastname !== undefined) {
                localVarQueryParameter['player_lastname'] = playerLastname;
            }

            if (playerEmail !== undefined) {
                localVarQueryParameter['player_email'] = playerEmail;
            }

            if (playerCountry !== undefined) {
                localVarQueryParameter['player_country'] = playerCountry;
            }

            if (playerDinner !== undefined) {
                localVarQueryParameter['player_dinner'] = playerDinner;
            }

            if (playerDivision !== undefined) {
                localVarQueryParameter['player_division'] = playerDivision;
            }

            if (playerCategories !== undefined) {
                localVarQueryParameter['player_categories'] = playerCategories;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (modifiedAt !== undefined) {
                localVarQueryParameter['modified_at'] = modifiedAt;
            }

            if (playerPhone !== undefined) {
                localVarQueryParameter['player_phone'] = playerPhone;
            }

            if (playerMusic !== undefined) {
                localVarQueryParameter['player_music'] = playerMusic;
            }

            if (playerDogAge !== undefined) {
                localVarQueryParameter['player_dog_age'] = playerDogAge;
            }

            if (playerDogName !== undefined) {
                localVarQueryParameter['player_dog_name'] = playerDogName;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventsRegistrations" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EventsRegistrations} [body] events_registrations
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRegistrationsPost(body?: EventsRegistrations, select?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/events_registrations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventsRegistrations" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsRegistrationsApi - functional programming interface
 * @export
 */
export const EventsRegistrationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [eventId] 
         * @param {string} [playerFirstname] 
         * @param {string} [playerLastname] 
         * @param {string} [playerEmail] 
         * @param {string} [playerCountry] 
         * @param {string} [playerDinner] 
         * @param {string} [playerDivision] 
         * @param {string} [playerCategories] 
         * @param {string} [createdAt] 
         * @param {string} [modifiedAt] 
         * @param {string} [playerPhone] 
         * @param {string} [playerMusic] 
         * @param {string} [playerDogAge] 
         * @param {string} [playerDogName] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRegistrationsDelete(id?: string, eventId?: string, playerFirstname?: string, playerLastname?: string, playerEmail?: string, playerCountry?: string, playerDinner?: string, playerDivision?: string, playerCategories?: string, createdAt?: string, modifiedAt?: string, playerPhone?: string, playerMusic?: string, playerDogAge?: string, playerDogName?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EventsRegistrationsApiFetchParamCreator(configuration).eventsRegistrationsDelete(id, eventId, playerFirstname, playerLastname, playerEmail, playerCountry, playerDinner, playerDivision, playerCategories, createdAt, modifiedAt, playerPhone, playerMusic, playerDogAge, playerDogName, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [eventId] 
         * @param {string} [playerFirstname] 
         * @param {string} [playerLastname] 
         * @param {string} [playerEmail] 
         * @param {string} [playerCountry] 
         * @param {string} [playerDinner] 
         * @param {string} [playerDivision] 
         * @param {string} [playerCategories] 
         * @param {string} [createdAt] 
         * @param {string} [modifiedAt] 
         * @param {string} [playerPhone] 
         * @param {string} [playerMusic] 
         * @param {string} [playerDogAge] 
         * @param {string} [playerDogName] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRegistrationsGet(id?: string, eventId?: string, playerFirstname?: string, playerLastname?: string, playerEmail?: string, playerCountry?: string, playerDinner?: string, playerDivision?: string, playerCategories?: string, createdAt?: string, modifiedAt?: string, playerPhone?: string, playerMusic?: string, playerDogAge?: string, playerDogName?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventsRegistrations>> {
            const localVarFetchArgs = EventsRegistrationsApiFetchParamCreator(configuration).eventsRegistrationsGet(id, eventId, playerFirstname, playerLastname, playerEmail, playerCountry, playerDinner, playerDivision, playerCategories, createdAt, modifiedAt, playerPhone, playerMusic, playerDogAge, playerDogName, select, order, range, rangeUnit, offset, limit, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EventsRegistrations} [body] events_registrations
         * @param {string} [id] 
         * @param {string} [eventId] 
         * @param {string} [playerFirstname] 
         * @param {string} [playerLastname] 
         * @param {string} [playerEmail] 
         * @param {string} [playerCountry] 
         * @param {string} [playerDinner] 
         * @param {string} [playerDivision] 
         * @param {string} [playerCategories] 
         * @param {string} [createdAt] 
         * @param {string} [modifiedAt] 
         * @param {string} [playerPhone] 
         * @param {string} [playerMusic] 
         * @param {string} [playerDogAge] 
         * @param {string} [playerDogName] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRegistrationsPatch(body?: EventsRegistrations, id?: string, eventId?: string, playerFirstname?: string, playerLastname?: string, playerEmail?: string, playerCountry?: string, playerDinner?: string, playerDivision?: string, playerCategories?: string, createdAt?: string, modifiedAt?: string, playerPhone?: string, playerMusic?: string, playerDogAge?: string, playerDogName?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EventsRegistrationsApiFetchParamCreator(configuration).eventsRegistrationsPatch(body, id, eventId, playerFirstname, playerLastname, playerEmail, playerCountry, playerDinner, playerDivision, playerCategories, createdAt, modifiedAt, playerPhone, playerMusic, playerDogAge, playerDogName, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EventsRegistrations} [body] events_registrations
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRegistrationsPost(body?: EventsRegistrations, select?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EventsRegistrationsApiFetchParamCreator(configuration).eventsRegistrationsPost(body, select, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventsRegistrationsApi - factory interface
 * @export
 */
export const EventsRegistrationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [eventId] 
         * @param {string} [playerFirstname] 
         * @param {string} [playerLastname] 
         * @param {string} [playerEmail] 
         * @param {string} [playerCountry] 
         * @param {string} [playerDinner] 
         * @param {string} [playerDivision] 
         * @param {string} [playerCategories] 
         * @param {string} [createdAt] 
         * @param {string} [modifiedAt] 
         * @param {string} [playerPhone] 
         * @param {string} [playerMusic] 
         * @param {string} [playerDogAge] 
         * @param {string} [playerDogName] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRegistrationsDelete(id?: string, eventId?: string, playerFirstname?: string, playerLastname?: string, playerEmail?: string, playerCountry?: string, playerDinner?: string, playerDivision?: string, playerCategories?: string, createdAt?: string, modifiedAt?: string, playerPhone?: string, playerMusic?: string, playerDogAge?: string, playerDogName?: string, prefer?: string, options?: any) {
            return EventsRegistrationsApiFp(configuration).eventsRegistrationsDelete(id, eventId, playerFirstname, playerLastname, playerEmail, playerCountry, playerDinner, playerDivision, playerCategories, createdAt, modifiedAt, playerPhone, playerMusic, playerDogAge, playerDogName, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [eventId] 
         * @param {string} [playerFirstname] 
         * @param {string} [playerLastname] 
         * @param {string} [playerEmail] 
         * @param {string} [playerCountry] 
         * @param {string} [playerDinner] 
         * @param {string} [playerDivision] 
         * @param {string} [playerCategories] 
         * @param {string} [createdAt] 
         * @param {string} [modifiedAt] 
         * @param {string} [playerPhone] 
         * @param {string} [playerMusic] 
         * @param {string} [playerDogAge] 
         * @param {string} [playerDogName] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRegistrationsGet(id?: string, eventId?: string, playerFirstname?: string, playerLastname?: string, playerEmail?: string, playerCountry?: string, playerDinner?: string, playerDivision?: string, playerCategories?: string, createdAt?: string, modifiedAt?: string, playerPhone?: string, playerMusic?: string, playerDogAge?: string, playerDogName?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
            return EventsRegistrationsApiFp(configuration).eventsRegistrationsGet(id, eventId, playerFirstname, playerLastname, playerEmail, playerCountry, playerDinner, playerDivision, playerCategories, createdAt, modifiedAt, playerPhone, playerMusic, playerDogAge, playerDogName, select, order, range, rangeUnit, offset, limit, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EventsRegistrations} [body] events_registrations
         * @param {string} [id] 
         * @param {string} [eventId] 
         * @param {string} [playerFirstname] 
         * @param {string} [playerLastname] 
         * @param {string} [playerEmail] 
         * @param {string} [playerCountry] 
         * @param {string} [playerDinner] 
         * @param {string} [playerDivision] 
         * @param {string} [playerCategories] 
         * @param {string} [createdAt] 
         * @param {string} [modifiedAt] 
         * @param {string} [playerPhone] 
         * @param {string} [playerMusic] 
         * @param {string} [playerDogAge] 
         * @param {string} [playerDogName] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRegistrationsPatch(body?: EventsRegistrations, id?: string, eventId?: string, playerFirstname?: string, playerLastname?: string, playerEmail?: string, playerCountry?: string, playerDinner?: string, playerDivision?: string, playerCategories?: string, createdAt?: string, modifiedAt?: string, playerPhone?: string, playerMusic?: string, playerDogAge?: string, playerDogName?: string, prefer?: string, options?: any) {
            return EventsRegistrationsApiFp(configuration).eventsRegistrationsPatch(body, id, eventId, playerFirstname, playerLastname, playerEmail, playerCountry, playerDinner, playerDivision, playerCategories, createdAt, modifiedAt, playerPhone, playerMusic, playerDogAge, playerDogName, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EventsRegistrations} [body] events_registrations
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRegistrationsPost(body?: EventsRegistrations, select?: string, prefer?: string, options?: any) {
            return EventsRegistrationsApiFp(configuration).eventsRegistrationsPost(body, select, prefer, options)(fetch, basePath);
        },
    };
};

/**
 * EventsRegistrationsApi - object-oriented interface
 * @export
 * @class EventsRegistrationsApi
 * @extends {BaseAPI}
 */
export class EventsRegistrationsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [eventId] 
     * @param {string} [playerFirstname] 
     * @param {string} [playerLastname] 
     * @param {string} [playerEmail] 
     * @param {string} [playerCountry] 
     * @param {string} [playerDinner] 
     * @param {string} [playerDivision] 
     * @param {string} [playerCategories] 
     * @param {string} [createdAt] 
     * @param {string} [modifiedAt] 
     * @param {string} [playerPhone] 
     * @param {string} [playerMusic] 
     * @param {string} [playerDogAge] 
     * @param {string} [playerDogName] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsRegistrationsApi
     */
    public eventsRegistrationsDelete(id?: string, eventId?: string, playerFirstname?: string, playerLastname?: string, playerEmail?: string, playerCountry?: string, playerDinner?: string, playerDivision?: string, playerCategories?: string, createdAt?: string, modifiedAt?: string, playerPhone?: string, playerMusic?: string, playerDogAge?: string, playerDogName?: string, prefer?: string, options?: any) {
        return EventsRegistrationsApiFp(this.configuration).eventsRegistrationsDelete(id, eventId, playerFirstname, playerLastname, playerEmail, playerCountry, playerDinner, playerDivision, playerCategories, createdAt, modifiedAt, playerPhone, playerMusic, playerDogAge, playerDogName, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [eventId] 
     * @param {string} [playerFirstname] 
     * @param {string} [playerLastname] 
     * @param {string} [playerEmail] 
     * @param {string} [playerCountry] 
     * @param {string} [playerDinner] 
     * @param {string} [playerDivision] 
     * @param {string} [playerCategories] 
     * @param {string} [createdAt] 
     * @param {string} [modifiedAt] 
     * @param {string} [playerPhone] 
     * @param {string} [playerMusic] 
     * @param {string} [playerDogAge] 
     * @param {string} [playerDogName] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsRegistrationsApi
     */
    public eventsRegistrationsGet(id?: string, eventId?: string, playerFirstname?: string, playerLastname?: string, playerEmail?: string, playerCountry?: string, playerDinner?: string, playerDivision?: string, playerCategories?: string, createdAt?: string, modifiedAt?: string, playerPhone?: string, playerMusic?: string, playerDogAge?: string, playerDogName?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
        return EventsRegistrationsApiFp(this.configuration).eventsRegistrationsGet(id, eventId, playerFirstname, playerLastname, playerEmail, playerCountry, playerDinner, playerDivision, playerCategories, createdAt, modifiedAt, playerPhone, playerMusic, playerDogAge, playerDogName, select, order, range, rangeUnit, offset, limit, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {EventsRegistrations} [body] events_registrations
     * @param {string} [id] 
     * @param {string} [eventId] 
     * @param {string} [playerFirstname] 
     * @param {string} [playerLastname] 
     * @param {string} [playerEmail] 
     * @param {string} [playerCountry] 
     * @param {string} [playerDinner] 
     * @param {string} [playerDivision] 
     * @param {string} [playerCategories] 
     * @param {string} [createdAt] 
     * @param {string} [modifiedAt] 
     * @param {string} [playerPhone] 
     * @param {string} [playerMusic] 
     * @param {string} [playerDogAge] 
     * @param {string} [playerDogName] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsRegistrationsApi
     */
    public eventsRegistrationsPatch(body?: EventsRegistrations, id?: string, eventId?: string, playerFirstname?: string, playerLastname?: string, playerEmail?: string, playerCountry?: string, playerDinner?: string, playerDivision?: string, playerCategories?: string, createdAt?: string, modifiedAt?: string, playerPhone?: string, playerMusic?: string, playerDogAge?: string, playerDogName?: string, prefer?: string, options?: any) {
        return EventsRegistrationsApiFp(this.configuration).eventsRegistrationsPatch(body, id, eventId, playerFirstname, playerLastname, playerEmail, playerCountry, playerDinner, playerDivision, playerCategories, createdAt, modifiedAt, playerPhone, playerMusic, playerDogAge, playerDogName, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {EventsRegistrations} [body] events_registrations
     * @param {string} [select] Filtering Columns
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsRegistrationsApi
     */
    public eventsRegistrationsPost(body?: EventsRegistrations, select?: string, prefer?: string, options?: any) {
        return EventsRegistrationsApiFp(this.configuration).eventsRegistrationsPost(body, select, prefer, options)(this.fetch, this.basePath);
    }

}
/**
 * FormatsApi - fetch parameter creator
 * @export
 */
export const FormatsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [sportId] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formatsDelete(id?: string, name?: string, sportId?: string, createdAt?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/formats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (sportId !== undefined) {
                localVarQueryParameter['sport_id'] = sportId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [sportId] 
         * @param {string} [createdAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formatsGet(id?: string, name?: string, sportId?: string, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/formats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (sportId !== undefined) {
                localVarQueryParameter['sport_id'] = sportId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Formats} [body] formats
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [sportId] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formatsPatch(body?: Formats, id?: string, name?: string, sportId?: string, createdAt?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/formats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (sportId !== undefined) {
                localVarQueryParameter['sport_id'] = sportId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Formats" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Formats} [body] formats
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formatsPost(body?: Formats, select?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/formats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Formats" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormatsApi - functional programming interface
 * @export
 */
export const FormatsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [sportId] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formatsDelete(id?: string, name?: string, sportId?: string, createdAt?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FormatsApiFetchParamCreator(configuration).formatsDelete(id, name, sportId, createdAt, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [sportId] 
         * @param {string} [createdAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formatsGet(id?: string, name?: string, sportId?: string, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Formats>> {
            const localVarFetchArgs = FormatsApiFetchParamCreator(configuration).formatsGet(id, name, sportId, createdAt, select, order, range, rangeUnit, offset, limit, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Formats} [body] formats
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [sportId] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formatsPatch(body?: Formats, id?: string, name?: string, sportId?: string, createdAt?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FormatsApiFetchParamCreator(configuration).formatsPatch(body, id, name, sportId, createdAt, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Formats} [body] formats
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formatsPost(body?: Formats, select?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FormatsApiFetchParamCreator(configuration).formatsPost(body, select, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FormatsApi - factory interface
 * @export
 */
export const FormatsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [sportId] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formatsDelete(id?: string, name?: string, sportId?: string, createdAt?: string, prefer?: string, options?: any) {
            return FormatsApiFp(configuration).formatsDelete(id, name, sportId, createdAt, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [sportId] 
         * @param {string} [createdAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formatsGet(id?: string, name?: string, sportId?: string, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
            return FormatsApiFp(configuration).formatsGet(id, name, sportId, createdAt, select, order, range, rangeUnit, offset, limit, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Formats} [body] formats
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [sportId] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formatsPatch(body?: Formats, id?: string, name?: string, sportId?: string, createdAt?: string, prefer?: string, options?: any) {
            return FormatsApiFp(configuration).formatsPatch(body, id, name, sportId, createdAt, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Formats} [body] formats
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formatsPost(body?: Formats, select?: string, prefer?: string, options?: any) {
            return FormatsApiFp(configuration).formatsPost(body, select, prefer, options)(fetch, basePath);
        },
    };
};

/**
 * FormatsApi - object-oriented interface
 * @export
 * @class FormatsApi
 * @extends {BaseAPI}
 */
export class FormatsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {string} [sportId] 
     * @param {string} [createdAt] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormatsApi
     */
    public formatsDelete(id?: string, name?: string, sportId?: string, createdAt?: string, prefer?: string, options?: any) {
        return FormatsApiFp(this.configuration).formatsDelete(id, name, sportId, createdAt, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {string} [sportId] 
     * @param {string} [createdAt] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormatsApi
     */
    public formatsGet(id?: string, name?: string, sportId?: string, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
        return FormatsApiFp(this.configuration).formatsGet(id, name, sportId, createdAt, select, order, range, rangeUnit, offset, limit, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Formats} [body] formats
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {string} [sportId] 
     * @param {string} [createdAt] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormatsApi
     */
    public formatsPatch(body?: Formats, id?: string, name?: string, sportId?: string, createdAt?: string, prefer?: string, options?: any) {
        return FormatsApiFp(this.configuration).formatsPatch(body, id, name, sportId, createdAt, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Formats} [body] formats
     * @param {string} [select] Filtering Columns
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormatsApi
     */
    public formatsPost(body?: Formats, select?: string, prefer?: string, options?: any) {
        return FormatsApiFp(this.configuration).formatsPost(body, select, prefer, options)(this.fetch, this.basePath);
    }

}
/**
 * IntrospectionApi - fetch parameter creator
 * @export
 */
export const IntrospectionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary OpenAPI description (this document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options: any = {}): FetchArgs {
            const localVarPath = `/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntrospectionApi - functional programming interface
 * @export
 */
export const IntrospectionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary OpenAPI description (this document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntrospectionApiFetchParamCreator(configuration).rootGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IntrospectionApi - factory interface
 * @export
 */
export const IntrospectionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary OpenAPI description (this document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any) {
            return IntrospectionApiFp(configuration).rootGet(options)(fetch, basePath);
        },
    };
};

/**
 * IntrospectionApi - object-oriented interface
 * @export
 * @class IntrospectionApi
 * @extends {BaseAPI}
 */
export class IntrospectionApi extends BaseAPI {
    /**
     * 
     * @summary OpenAPI description (this document)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntrospectionApi
     */
    public rootGet(options?: any) {
        return IntrospectionApiFp(this.configuration).rootGet(options)(this.fetch, this.basePath);
    }

}
/**
 * ProfilesApi - fetch parameter creator
 * @export
 */
export const ProfilesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [username] 
         * @param {string} [fullName] 
         * @param {string} [avatarUrl] 
         * @param {string} [website] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesDelete(id?: string, updatedAt?: string, username?: string, fullName?: string, avatarUrl?: string, website?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/profiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (fullName !== undefined) {
                localVarQueryParameter['full_name'] = fullName;
            }

            if (avatarUrl !== undefined) {
                localVarQueryParameter['avatar_url'] = avatarUrl;
            }

            if (website !== undefined) {
                localVarQueryParameter['website'] = website;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [username] 
         * @param {string} [fullName] 
         * @param {string} [avatarUrl] 
         * @param {string} [website] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesGet(id?: string, updatedAt?: string, username?: string, fullName?: string, avatarUrl?: string, website?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/profiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (fullName !== undefined) {
                localVarQueryParameter['full_name'] = fullName;
            }

            if (avatarUrl !== undefined) {
                localVarQueryParameter['avatar_url'] = avatarUrl;
            }

            if (website !== undefined) {
                localVarQueryParameter['website'] = website;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Profiles} [body] profiles
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [username] 
         * @param {string} [fullName] 
         * @param {string} [avatarUrl] 
         * @param {string} [website] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesPatch(body?: Profiles, id?: string, updatedAt?: string, username?: string, fullName?: string, avatarUrl?: string, website?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/profiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (fullName !== undefined) {
                localVarQueryParameter['full_name'] = fullName;
            }

            if (avatarUrl !== undefined) {
                localVarQueryParameter['avatar_url'] = avatarUrl;
            }

            if (website !== undefined) {
                localVarQueryParameter['website'] = website;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Profiles" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Profiles} [body] profiles
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesPost(body?: Profiles, select?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/profiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Profiles" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [username] 
         * @param {string} [fullName] 
         * @param {string} [avatarUrl] 
         * @param {string} [website] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesDelete(id?: string, updatedAt?: string, username?: string, fullName?: string, avatarUrl?: string, website?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).profilesDelete(id, updatedAt, username, fullName, avatarUrl, website, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [username] 
         * @param {string} [fullName] 
         * @param {string} [avatarUrl] 
         * @param {string} [website] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesGet(id?: string, updatedAt?: string, username?: string, fullName?: string, avatarUrl?: string, website?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Profiles>> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).profilesGet(id, updatedAt, username, fullName, avatarUrl, website, select, order, range, rangeUnit, offset, limit, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Profiles} [body] profiles
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [username] 
         * @param {string} [fullName] 
         * @param {string} [avatarUrl] 
         * @param {string} [website] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesPatch(body?: Profiles, id?: string, updatedAt?: string, username?: string, fullName?: string, avatarUrl?: string, website?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).profilesPatch(body, id, updatedAt, username, fullName, avatarUrl, website, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Profiles} [body] profiles
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesPost(body?: Profiles, select?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfilesApiFetchParamCreator(configuration).profilesPost(body, select, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [username] 
         * @param {string} [fullName] 
         * @param {string} [avatarUrl] 
         * @param {string} [website] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesDelete(id?: string, updatedAt?: string, username?: string, fullName?: string, avatarUrl?: string, website?: string, prefer?: string, options?: any) {
            return ProfilesApiFp(configuration).profilesDelete(id, updatedAt, username, fullName, avatarUrl, website, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [username] 
         * @param {string} [fullName] 
         * @param {string} [avatarUrl] 
         * @param {string} [website] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesGet(id?: string, updatedAt?: string, username?: string, fullName?: string, avatarUrl?: string, website?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
            return ProfilesApiFp(configuration).profilesGet(id, updatedAt, username, fullName, avatarUrl, website, select, order, range, rangeUnit, offset, limit, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Profiles} [body] profiles
         * @param {string} [id] 
         * @param {string} [updatedAt] 
         * @param {string} [username] 
         * @param {string} [fullName] 
         * @param {string} [avatarUrl] 
         * @param {string} [website] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesPatch(body?: Profiles, id?: string, updatedAt?: string, username?: string, fullName?: string, avatarUrl?: string, website?: string, prefer?: string, options?: any) {
            return ProfilesApiFp(configuration).profilesPatch(body, id, updatedAt, username, fullName, avatarUrl, website, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Profiles} [body] profiles
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesPost(body?: Profiles, select?: string, prefer?: string, options?: any) {
            return ProfilesApiFp(configuration).profilesPost(body, select, prefer, options)(fetch, basePath);
        },
    };
};

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [updatedAt] 
     * @param {string} [username] 
     * @param {string} [fullName] 
     * @param {string} [avatarUrl] 
     * @param {string} [website] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesDelete(id?: string, updatedAt?: string, username?: string, fullName?: string, avatarUrl?: string, website?: string, prefer?: string, options?: any) {
        return ProfilesApiFp(this.configuration).profilesDelete(id, updatedAt, username, fullName, avatarUrl, website, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [updatedAt] 
     * @param {string} [username] 
     * @param {string} [fullName] 
     * @param {string} [avatarUrl] 
     * @param {string} [website] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesGet(id?: string, updatedAt?: string, username?: string, fullName?: string, avatarUrl?: string, website?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
        return ProfilesApiFp(this.configuration).profilesGet(id, updatedAt, username, fullName, avatarUrl, website, select, order, range, rangeUnit, offset, limit, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Profiles} [body] profiles
     * @param {string} [id] 
     * @param {string} [updatedAt] 
     * @param {string} [username] 
     * @param {string} [fullName] 
     * @param {string} [avatarUrl] 
     * @param {string} [website] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesPatch(body?: Profiles, id?: string, updatedAt?: string, username?: string, fullName?: string, avatarUrl?: string, website?: string, prefer?: string, options?: any) {
        return ProfilesApiFp(this.configuration).profilesPatch(body, id, updatedAt, username, fullName, avatarUrl, website, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Profiles} [body] profiles
     * @param {string} [select] Filtering Columns
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesPost(body?: Profiles, select?: string, prefer?: string, options?: any) {
        return ProfilesApiFp(this.configuration).profilesPost(body, select, prefer, options)(this.fetch, this.basePath);
    }

}
/**
 * RpcDeleteAvatarApi - fetch parameter creator
 * @export
 */
export const RpcDeleteAvatarApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} avatarUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcDeleteAvatarGet(avatarUrl: string, options: any = {}): FetchArgs {
            // verify required parameter 'avatarUrl' is not null or undefined
            if (avatarUrl === null || avatarUrl === undefined) {
                throw new RequiredError('avatarUrl','Required parameter avatarUrl was null or undefined when calling rpcDeleteAvatarGet.');
            }
            const localVarPath = `/rpc/delete_avatar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (avatarUrl !== undefined) {
                localVarQueryParameter['avatar_url'] = avatarUrl;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RpcDeleteAvatarBody} body 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcDeleteAvatarPost(body: RpcDeleteAvatarBody, prefer?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rpcDeleteAvatarPost.');
            }
            const localVarPath = `/rpc/delete_avatar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RpcDeleteAvatarBody3" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcDeleteAvatarApi - functional programming interface
 * @export
 */
export const RpcDeleteAvatarApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} avatarUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcDeleteAvatarGet(avatarUrl: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RpcDeleteAvatarApiFetchParamCreator(configuration).rpcDeleteAvatarGet(avatarUrl, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RpcDeleteAvatarBody} body 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcDeleteAvatarPost(body: RpcDeleteAvatarBody, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RpcDeleteAvatarApiFetchParamCreator(configuration).rpcDeleteAvatarPost(body, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RpcDeleteAvatarApi - factory interface
 * @export
 */
export const RpcDeleteAvatarApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} avatarUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcDeleteAvatarGet(avatarUrl: string, options?: any) {
            return RpcDeleteAvatarApiFp(configuration).rpcDeleteAvatarGet(avatarUrl, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RpcDeleteAvatarBody} body 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcDeleteAvatarPost(body: RpcDeleteAvatarBody, prefer?: string, options?: any) {
            return RpcDeleteAvatarApiFp(configuration).rpcDeleteAvatarPost(body, prefer, options)(fetch, basePath);
        },
    };
};

/**
 * RpcDeleteAvatarApi - object-oriented interface
 * @export
 * @class RpcDeleteAvatarApi
 * @extends {BaseAPI}
 */
export class RpcDeleteAvatarApi extends BaseAPI {
    /**
     * 
     * @param {string} avatarUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcDeleteAvatarApi
     */
    public rpcDeleteAvatarGet(avatarUrl: string, options?: any) {
        return RpcDeleteAvatarApiFp(this.configuration).rpcDeleteAvatarGet(avatarUrl, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RpcDeleteAvatarBody} body 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcDeleteAvatarApi
     */
    public rpcDeleteAvatarPost(body: RpcDeleteAvatarBody, prefer?: string, options?: any) {
        return RpcDeleteAvatarApiFp(this.configuration).rpcDeleteAvatarPost(body, prefer, options)(this.fetch, this.basePath);
    }

}
/**
 * RpcDeleteStorageObjectApi - fetch parameter creator
 * @export
 */
export const RpcDeleteStorageObjectApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} bucket 
         * @param {string} object 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcDeleteStorageObjectGet(bucket: string, object: string, options: any = {}): FetchArgs {
            // verify required parameter 'bucket' is not null or undefined
            if (bucket === null || bucket === undefined) {
                throw new RequiredError('bucket','Required parameter bucket was null or undefined when calling rpcDeleteStorageObjectGet.');
            }
            // verify required parameter 'object' is not null or undefined
            if (object === null || object === undefined) {
                throw new RequiredError('object','Required parameter object was null or undefined when calling rpcDeleteStorageObjectGet.');
            }
            const localVarPath = `/rpc/delete_storage_object`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bucket !== undefined) {
                localVarQueryParameter['bucket'] = bucket;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RpcDeleteStorageObjectBody} body 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcDeleteStorageObjectPost(body: RpcDeleteStorageObjectBody, prefer?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rpcDeleteStorageObjectPost.');
            }
            const localVarPath = `/rpc/delete_storage_object`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RpcDeleteStorageObjectBody3" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpcDeleteStorageObjectApi - functional programming interface
 * @export
 */
export const RpcDeleteStorageObjectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} bucket 
         * @param {string} object 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcDeleteStorageObjectGet(bucket: string, object: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RpcDeleteStorageObjectApiFetchParamCreator(configuration).rpcDeleteStorageObjectGet(bucket, object, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RpcDeleteStorageObjectBody} body 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcDeleteStorageObjectPost(body: RpcDeleteStorageObjectBody, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RpcDeleteStorageObjectApiFetchParamCreator(configuration).rpcDeleteStorageObjectPost(body, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RpcDeleteStorageObjectApi - factory interface
 * @export
 */
export const RpcDeleteStorageObjectApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} bucket 
         * @param {string} object 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcDeleteStorageObjectGet(bucket: string, object: string, options?: any) {
            return RpcDeleteStorageObjectApiFp(configuration).rpcDeleteStorageObjectGet(bucket, object, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RpcDeleteStorageObjectBody} body 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpcDeleteStorageObjectPost(body: RpcDeleteStorageObjectBody, prefer?: string, options?: any) {
            return RpcDeleteStorageObjectApiFp(configuration).rpcDeleteStorageObjectPost(body, prefer, options)(fetch, basePath);
        },
    };
};

/**
 * RpcDeleteStorageObjectApi - object-oriented interface
 * @export
 * @class RpcDeleteStorageObjectApi
 * @extends {BaseAPI}
 */
export class RpcDeleteStorageObjectApi extends BaseAPI {
    /**
     * 
     * @param {string} bucket 
     * @param {string} object 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcDeleteStorageObjectApi
     */
    public rpcDeleteStorageObjectGet(bucket: string, object: string, options?: any) {
        return RpcDeleteStorageObjectApiFp(this.configuration).rpcDeleteStorageObjectGet(bucket, object, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RpcDeleteStorageObjectBody} body 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpcDeleteStorageObjectApi
     */
    public rpcDeleteStorageObjectPost(body: RpcDeleteStorageObjectBody, prefer?: string, options?: any) {
        return RpcDeleteStorageObjectApiFp(this.configuration).rpcDeleteStorageObjectPost(body, prefer, options)(this.fetch, this.basePath);
    }

}
/**
 * SportsApi - fetch parameter creator
 * @export
 */
export const SportsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sportsDelete(id?: string, name?: string, createdAt?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sports`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [createdAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sportsGet(id?: string, name?: string, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sports`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Sports} [body] sports
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sportsPatch(body?: Sports, id?: string, name?: string, createdAt?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sports`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Sports" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Sports} [body] sports
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sportsPost(body?: Sports, select?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/sports`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Sports" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SportsApi - functional programming interface
 * @export
 */
export const SportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sportsDelete(id?: string, name?: string, createdAt?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SportsApiFetchParamCreator(configuration).sportsDelete(id, name, createdAt, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                console.log('me at fetch!');
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [createdAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sportsGet(id?: string, name?: string, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Sports>> {
            const localVarFetchArgs = SportsApiFetchParamCreator(configuration).sportsGet(id, name, createdAt, select, order, range, rangeUnit, offset, limit, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Sports} [body] sports
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sportsPatch(body?: Sports, id?: string, name?: string, createdAt?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SportsApiFetchParamCreator(configuration).sportsPatch(body, id, name, createdAt, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Sports} [body] sports
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sportsPost(body?: Sports, select?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SportsApiFetchParamCreator(configuration).sportsPost(body, select, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SportsApi - factory interface
 * @export
 */
export const SportsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sportsDelete(id?: string, name?: string, createdAt?: string, prefer?: string, options?: any) {
            return SportsApiFp(configuration).sportsDelete(id, name, createdAt, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [createdAt] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sportsGet(id?: string, name?: string, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
            return SportsApiFp(configuration).sportsGet(id, name, createdAt, select, order, range, rangeUnit, offset, limit, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Sports} [body] sports
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [createdAt] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sportsPatch(body?: Sports, id?: string, name?: string, createdAt?: string, prefer?: string, options?: any) {
            return SportsApiFp(configuration).sportsPatch(body, id, name, createdAt, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Sports} [body] sports
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sportsPost(body?: Sports, select?: string, prefer?: string, options?: any) {
            return SportsApiFp(configuration).sportsPost(body, select, prefer, options)(fetch, basePath);
        },
    };
};

/**
 * SportsApi - object-oriented interface
 * @export
 * @class SportsApi
 * @extends {BaseAPI}
 */
export class SportsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {string} [createdAt] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SportsApi
     */
    public sportsDelete(id?: string, name?: string, createdAt?: string, prefer?: string, options?: any) {
        return SportsApiFp(this.configuration).sportsDelete(id, name, createdAt, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {string} [createdAt] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SportsApi
     */
    public sportsGet(id?: string, name?: string, createdAt?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
        return SportsApiFp(this.configuration).sportsGet(id, name, createdAt, select, order, range, rangeUnit, offset, limit, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Sports} [body] sports
     * @param {string} [id] 
     * @param {string} [name] 
     * @param {string} [createdAt] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SportsApi
     */
    public sportsPatch(body?: Sports, id?: string, name?: string, createdAt?: string, prefer?: string, options?: any) {
        return SportsApiFp(this.configuration).sportsPatch(body, id, name, createdAt, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Sports} [body] sports
     * @param {string} [select] Filtering Columns
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SportsApi
     */
    public sportsPost(body?: Sports, select?: string, prefer?: string, options?: any) {
        return SportsApiFp(this.configuration).sportsPost(body, select, prefer, options)(this.fetch, this.basePath);
    }

}
/**
 * TodosApi - fetch parameter creator
 * @export
 */
export const TodosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [task] 
         * @param {string} [name] 
         * @param {string} [userId] 
         * @param {string} [completed] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        todosDelete(id?: string, createdAt?: string, task?: string, name?: string, userId?: string, completed?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/todos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (task !== undefined) {
                localVarQueryParameter['task'] = task;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (completed !== undefined) {
                localVarQueryParameter['completed'] = completed;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [task] 
         * @param {string} [name] 
         * @param {string} [userId] 
         * @param {string} [completed] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        todosGet(id?: string, createdAt?: string, task?: string, name?: string, userId?: string, completed?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/todos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (task !== undefined) {
                localVarQueryParameter['task'] = task;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (completed !== undefined) {
                localVarQueryParameter['completed'] = completed;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }

            if (rangeUnit !== undefined && rangeUnit !== null) {
                localVarHeaderParameter['Range-Unit'] = String(rangeUnit);
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Todos} [body] todos
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [task] 
         * @param {string} [name] 
         * @param {string} [userId] 
         * @param {string} [completed] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        todosPatch(body?: Todos, id?: string, createdAt?: string, task?: string, name?: string, userId?: string, completed?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/todos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (task !== undefined) {
                localVarQueryParameter['task'] = task;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (completed !== undefined) {
                localVarQueryParameter['completed'] = completed;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Todos" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Todos} [body] todos
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        todosPost(body?: Todos, select?: string, prefer?: string, options: any = {}): FetchArgs {
            const localVarPath = `/todos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (prefer !== undefined && prefer !== null) {
                localVarHeaderParameter['Prefer'] = String(prefer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Todos" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TodosApi - functional programming interface
 * @export
 */
export const TodosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [task] 
         * @param {string} [name] 
         * @param {string} [userId] 
         * @param {string} [completed] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        todosDelete(id?: string, createdAt?: string, task?: string, name?: string, userId?: string, completed?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TodosApiFetchParamCreator(configuration).todosDelete(id, createdAt, task, name, userId, completed, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [task] 
         * @param {string} [name] 
         * @param {string} [userId] 
         * @param {string} [completed] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        todosGet(id?: string, createdAt?: string, task?: string, name?: string, userId?: string, completed?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Todos>> {
            const localVarFetchArgs = TodosApiFetchParamCreator(configuration).todosGet(id, createdAt, task, name, userId, completed, select, order, range, rangeUnit, offset, limit, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Todos} [body] todos
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [task] 
         * @param {string} [name] 
         * @param {string} [userId] 
         * @param {string} [completed] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        todosPatch(body?: Todos, id?: string, createdAt?: string, task?: string, name?: string, userId?: string, completed?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TodosApiFetchParamCreator(configuration).todosPatch(body, id, createdAt, task, name, userId, completed, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Todos} [body] todos
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        todosPost(body?: Todos, select?: string, prefer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TodosApiFetchParamCreator(configuration).todosPost(body, select, prefer, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TodosApi - factory interface
 * @export
 */
export const TodosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [task] 
         * @param {string} [name] 
         * @param {string} [userId] 
         * @param {string} [completed] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        todosDelete(id?: string, createdAt?: string, task?: string, name?: string, userId?: string, completed?: string, prefer?: string, options?: any) {
            return TodosApiFp(configuration).todosDelete(id, createdAt, task, name, userId, completed, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [task] 
         * @param {string} [name] 
         * @param {string} [userId] 
         * @param {string} [completed] 
         * @param {string} [select] Filtering Columns
         * @param {string} [order] Ordering
         * @param {string} [range] Limiting and Pagination
         * @param {string} [rangeUnit] Limiting and Pagination
         * @param {string} [offset] Limiting and Pagination
         * @param {string} [limit] Limiting and Pagination
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        todosGet(id?: string, createdAt?: string, task?: string, name?: string, userId?: string, completed?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
            return TodosApiFp(configuration).todosGet(id, createdAt, task, name, userId, completed, select, order, range, rangeUnit, offset, limit, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Todos} [body] todos
         * @param {string} [id] 
         * @param {string} [createdAt] 
         * @param {string} [task] 
         * @param {string} [name] 
         * @param {string} [userId] 
         * @param {string} [completed] 
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        todosPatch(body?: Todos, id?: string, createdAt?: string, task?: string, name?: string, userId?: string, completed?: string, prefer?: string, options?: any) {
            return TodosApiFp(configuration).todosPatch(body, id, createdAt, task, name, userId, completed, prefer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Todos} [body] todos
         * @param {string} [select] Filtering Columns
         * @param {string} [prefer] Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        todosPost(body?: Todos, select?: string, prefer?: string, options?: any) {
            return TodosApiFp(configuration).todosPost(body, select, prefer, options)(fetch, basePath);
        },
    };
};

/**
 * TodosApi - object-oriented interface
 * @export
 * @class TodosApi
 * @extends {BaseAPI}
 */
export class TodosApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [task] 
     * @param {string} [name] 
     * @param {string} [userId] 
     * @param {string} [completed] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TodosApi
     */
    public todosDelete(id?: string, createdAt?: string, task?: string, name?: string, userId?: string, completed?: string, prefer?: string, options?: any) {
        return TodosApiFp(this.configuration).todosDelete(id, createdAt, task, name, userId, completed, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [task] 
     * @param {string} [name] 
     * @param {string} [userId] 
     * @param {string} [completed] 
     * @param {string} [select] Filtering Columns
     * @param {string} [order] Ordering
     * @param {string} [range] Limiting and Pagination
     * @param {string} [rangeUnit] Limiting and Pagination
     * @param {string} [offset] Limiting and Pagination
     * @param {string} [limit] Limiting and Pagination
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TodosApi
     */
    public todosGet(id?: string, createdAt?: string, task?: string, name?: string, userId?: string, completed?: string, select?: string, order?: string, range?: string, rangeUnit?: string, offset?: string, limit?: string, prefer?: string, options?: any) {
        return TodosApiFp(this.configuration).todosGet(id, createdAt, task, name, userId, completed, select, order, range, rangeUnit, offset, limit, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Todos} [body] todos
     * @param {string} [id] 
     * @param {string} [createdAt] 
     * @param {string} [task] 
     * @param {string} [name] 
     * @param {string} [userId] 
     * @param {string} [completed] 
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TodosApi
     */
    public todosPatch(body?: Todos, id?: string, createdAt?: string, task?: string, name?: string, userId?: string, completed?: string, prefer?: string, options?: any) {
        return TodosApiFp(this.configuration).todosPatch(body, id, createdAt, task, name, userId, completed, prefer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Todos} [body] todos
     * @param {string} [select] Filtering Columns
     * @param {string} [prefer] Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TodosApi
     */
    public todosPost(body?: Todos, select?: string, prefer?: string, options?: any) {
        return TodosApiFp(this.configuration).todosPost(body, select, prefer, options)(this.fetch, this.basePath);
    }

}
